// Code generated by truss. DO NOT EDIT.
// Rerunning truss will overwrite this file.
// Version: 7dc4d5d85c
// Version Date: Mon May 28 22:12:59 UTC 2018

package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"os"
	"strconv"
	"strings"
	"time"

	"context"

	"google.golang.org/grpc"

	"github.com/pkg/errors"

	// This Service
	"test/accountsvc/rpc/account-service/svc/client/cli/handlers"
	grpcclient "test/accountsvc/rpc/account-service/svc/client/grpc"
	httpclient "test/accountsvc/rpc/account-service/svc/client/http"
	pb "test/accountsvc/rpc/pb"
)

var (
	_ = strconv.ParseInt
	_ = strings.Split
	_ = json.Compact
	_ = errors.Wrapf
	_ = pb.RegisterAccountServer
)

func main() {
	os.Exit(submain())
}

type headerSeries []string

func (h *headerSeries) Set(val string) error {
	const requiredParts int = 2
	parts := strings.SplitN(val, ":", requiredParts)
	if len(parts) != requiredParts {
		return fmt.Errorf("value %q cannot be split in two; must contain at least one ':' character", val)
	}
	parts[1] = strings.TrimSpace(parts[1])
	*h = append(*h, parts...)
	return nil
}

func (h *headerSeries) String() string {
	return fmt.Sprintf("%v", []string(*h))
}

// submain exists to act as the functional main, but will return exit codes to
// the actual main instead of calling os.Exit directly. This is done to allow
// the defered functions to be called, since if os.Exit where called directly
// from this function, none of the defered functions set up by this function
// would be called.
func submain() int {
	var headers headerSeries
	flag.Var(&headers, "header", "Header(s) to be sent in the transport (follows cURL style)")
	var (
		httpAddr = flag.String("http.addr", "", "HTTP address of addsvc")
		grpcAddr = flag.String("grpc.addr", ":5040", "gRPC (HTTP) address of addsvc")
	)

	// The addcli presumes no service discovery system, and expects users to
	// provide the direct address of an service. This presumption is reflected in
	// the cli binary and the the client packages: the -transport.addr flags
	// and various client constructors both expect host:port strings.

	fsGetAccountCount := flag.NewFlagSet("getaccountcount", flag.ExitOnError)

	fsGetAccountInfo := flag.NewFlagSet("getaccountinfo", flag.ExitOnError)

	fsGetAccountList := flag.NewFlagSet("getaccountlist", flag.ExitOnError)

	fsGetSessionInfo := flag.NewFlagSet("getsessioninfo", flag.ExitOnError)

	fsGetSessionUserData := flag.NewFlagSet("getsessionuserdata", flag.ExitOnError)

	fsLogin := flag.NewFlagSet("login", flag.ExitOnError)

	fsLogout := flag.NewFlagSet("logout", flag.ExitOnError)

	fsRegisterApp := flag.NewFlagSet("registerapp", flag.ExitOnError)

	fsRegisterLDAPAccount := flag.NewFlagSet("registerldapaccount", flag.ExitOnError)

	fsRegisterLocalAccount := flag.NewFlagSet("registerlocalaccount", flag.ExitOnError)

	fsSetSessionUserData := flag.NewFlagSet("setsessionuserdata", flag.ExitOnError)

	fsUnRegisterAccount := flag.NewFlagSet("unregisteraccount", flag.ExitOnError)

	fsUnRegisterApp := flag.NewFlagSet("unregisterapp", flag.ExitOnError)

	var (
		flagCommonRegisterLDAPAccount       = fsRegisterLDAPAccount.String("common", "", "")
		flagEmailRegisterLDAPAccount        = fsRegisterLDAPAccount.String("email", "", "")
		flagCommonUnRegisterAccount         = fsUnRegisterAccount.String("common", "", "")
		flagAccountIdUnRegisterAccount      = fsUnRegisterAccount.String("accountid", "", "")
		flagCommonGetAccountCount           = fsGetAccountCount.String("common", "", "")
		flagCommonGetAccountList            = fsGetAccountList.String("common", "", "")
		flagStartIndexGetAccountList        = fsGetAccountList.Int("startindex", 0, "")
		flagCountGetAccountList             = fsGetAccountList.Int("count", 0, "")
		flagCommonUnRegisterApp             = fsUnRegisterApp.String("common", "", "")
		flagCommonSetSessionUserData        = fsSetSessionUserData.String("common", "", "")
		flagUserDataSetSessionUserData      = fsSetSessionUserData.String("userdata", "", "")
		flagCommonGetSessionUserData        = fsGetSessionUserData.String("common", "", "")
		flagCommonRegisterApp               = fsRegisterApp.String("common", "", "")
		flagAppNameRegisterApp              = fsRegisterApp.String("appname", "", "")
		flagAppRedirectIdRegisterApp        = fsRegisterApp.String("appredirectid", "", "")
		flagCommonRegisterLocalAccount      = fsRegisterLocalAccount.String("common", "", "")
		flagEmailRegisterLocalAccount       = fsRegisterLocalAccount.String("email", "", "")
		flagUserNameRegisterLocalAccount    = fsRegisterLocalAccount.String("username", "", "")
		flagDisplayNameRegisterLocalAccount = fsRegisterLocalAccount.String("displayname", "", "")
		flagPasswordRegisterLocalAccount    = fsRegisterLocalAccount.String("password", "", "")
		flagCommonGetAccountInfo            = fsGetAccountInfo.String("common", "", "")
		flagAccountIdGetAccountInfo         = fsGetAccountInfo.String("accountid", "", "")
		flagCommonLogin                     = fsLogin.String("common", "", "")
		flagUserNameLogin                   = fsLogin.String("username", "", "")
		flagPasswordLogin                   = fsLogin.String("password", "", "")
		flagCommonLogout                    = fsLogout.String("common", "", "")
		flagCommonGetSessionInfo            = fsGetSessionInfo.String("common", "", "")
	)

	flag.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage of %s:\n", os.Args[0])
		flag.PrintDefaults()
		fmt.Fprintf(os.Stderr, "\n")
		fmt.Fprintf(os.Stderr, "Subcommands:\n")
		fmt.Fprintf(os.Stderr, "  %s\n", "getaccountcount")
		fmt.Fprintf(os.Stderr, "  %s\n", "getaccountinfo")
		fmt.Fprintf(os.Stderr, "  %s\n", "getaccountlist")
		fmt.Fprintf(os.Stderr, "  %s\n", "getsessioninfo")
		fmt.Fprintf(os.Stderr, "  %s\n", "getsessionuserdata")
		fmt.Fprintf(os.Stderr, "  %s\n", "login")
		fmt.Fprintf(os.Stderr, "  %s\n", "logout")
		fmt.Fprintf(os.Stderr, "  %s\n", "registerapp")
		fmt.Fprintf(os.Stderr, "  %s\n", "registerldapaccount")
		fmt.Fprintf(os.Stderr, "  %s\n", "registerlocalaccount")
		fmt.Fprintf(os.Stderr, "  %s\n", "setsessionuserdata")
		fmt.Fprintf(os.Stderr, "  %s\n", "unregisteraccount")
		fmt.Fprintf(os.Stderr, "  %s\n", "unregisterapp")
	}
	if len(os.Args) < 2 {
		flag.Usage()
		return 1
	}

	flag.Parse()

	var (
		service pb.AccountServer
		err     error
	)

	if *httpAddr != "" {
		service, err = httpclient.New(*httpAddr, httpclient.CtxValuesToSend(headers...))
	} else if *grpcAddr != "" {
		conn, err := grpc.Dial(*grpcAddr, grpc.WithInsecure(), grpc.WithTimeout(time.Second))
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error while dialing grpc connection: %v", err)
			return 1
		}
		defer conn.Close()
		service, err = grpcclient.New(conn, grpcclient.CtxValuesToSend(headers...))
	} else {
		fmt.Fprintf(os.Stderr, "error: no remote address specified\n")
		return 1
	}
	if err != nil {
		fmt.Fprintf(os.Stderr, "error: %v\n", err)
		return 1
	}

	if len(flag.Args()) < 1 {
		fmt.Printf("No 'method' subcommand provided; exiting.")
		flag.Usage()
		return 1
	}

	ctx := context.Background()
	for i := 0; i < len(headers); i += 2 {
		ctx = context.WithValue(ctx, headers[i], headers[i+1])
	}

	switch flag.Args()[0] {

	case "getaccountcount":
		fsGetAccountCount.Parse(flag.Args()[1:])

		var CommonGetAccountCount pb.CommonReq
		if flagCommonGetAccountCount != nil && len(*flagCommonGetAccountCount) > 0 {
			err = json.Unmarshal([]byte(*flagCommonGetAccountCount), &CommonGetAccountCount)
			if err != nil {
				panic(errors.Wrapf(err, "unmarshalling CommonGetAccountCount from %v:", flagCommonGetAccountCount))
			}
		}

		request, err := handlers.GetAccountCount(CommonGetAccountCount)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error calling handlers.GetAccountCount: %v\n", err)
			return 1
		}

		v, err := service.GetAccountCount(ctx, request)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error calling service.GetAccountCount: %v\n", err)
			return 1
		}
		fmt.Println("Client Requested with:")
		fmt.Println(CommonGetAccountCount)
		fmt.Println("Server Responded with:")
		fmt.Println(v)

	case "getaccountinfo":
		fsGetAccountInfo.Parse(flag.Args()[1:])

		var CommonGetAccountInfo pb.CommonReq
		if flagCommonGetAccountInfo != nil && len(*flagCommonGetAccountInfo) > 0 {
			err = json.Unmarshal([]byte(*flagCommonGetAccountInfo), &CommonGetAccountInfo)
			if err != nil {
				panic(errors.Wrapf(err, "unmarshalling CommonGetAccountInfo from %v:", flagCommonGetAccountInfo))
			}
		}

		AccountIdGetAccountInfo := *flagAccountIdGetAccountInfo

		request, err := handlers.GetAccountInfo(CommonGetAccountInfo, AccountIdGetAccountInfo)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error calling handlers.GetAccountInfo: %v\n", err)
			return 1
		}

		v, err := service.GetAccountInfo(ctx, request)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error calling service.GetAccountInfo: %v\n", err)
			return 1
		}
		fmt.Println("Client Requested with:")
		fmt.Println(CommonGetAccountInfo, AccountIdGetAccountInfo)
		fmt.Println("Server Responded with:")
		fmt.Println(v)

	case "getaccountlist":
		fsGetAccountList.Parse(flag.Args()[1:])

		var CommonGetAccountList pb.CommonReq
		if flagCommonGetAccountList != nil && len(*flagCommonGetAccountList) > 0 {
			err = json.Unmarshal([]byte(*flagCommonGetAccountList), &CommonGetAccountList)
			if err != nil {
				panic(errors.Wrapf(err, "unmarshalling CommonGetAccountList from %v:", flagCommonGetAccountList))
			}
		}

		StartIndexGetAccountList := int32(*flagStartIndexGetAccountList)
		CountGetAccountList := int32(*flagCountGetAccountList)

		request, err := handlers.GetAccountList(CommonGetAccountList, StartIndexGetAccountList, CountGetAccountList)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error calling handlers.GetAccountList: %v\n", err)
			return 1
		}

		v, err := service.GetAccountList(ctx, request)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error calling service.GetAccountList: %v\n", err)
			return 1
		}
		fmt.Println("Client Requested with:")
		fmt.Println(CommonGetAccountList, StartIndexGetAccountList, CountGetAccountList)
		fmt.Println("Server Responded with:")
		fmt.Println(v)

	case "getsessioninfo":
		fsGetSessionInfo.Parse(flag.Args()[1:])

		var CommonGetSessionInfo pb.CommonReq
		if flagCommonGetSessionInfo != nil && len(*flagCommonGetSessionInfo) > 0 {
			err = json.Unmarshal([]byte(*flagCommonGetSessionInfo), &CommonGetSessionInfo)
			if err != nil {
				panic(errors.Wrapf(err, "unmarshalling CommonGetSessionInfo from %v:", flagCommonGetSessionInfo))
			}
		}

		request, err := handlers.GetSessionInfo(CommonGetSessionInfo)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error calling handlers.GetSessionInfo: %v\n", err)
			return 1
		}

		v, err := service.GetSessionInfo(ctx, request)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error calling service.GetSessionInfo: %v\n", err)
			return 1
		}
		fmt.Println("Client Requested with:")
		fmt.Println(CommonGetSessionInfo)
		fmt.Println("Server Responded with:")
		fmt.Println(v)

	case "getsessionuserdata":
		fsGetSessionUserData.Parse(flag.Args()[1:])

		var CommonGetSessionUserData pb.CommonReq
		if flagCommonGetSessionUserData != nil && len(*flagCommonGetSessionUserData) > 0 {
			err = json.Unmarshal([]byte(*flagCommonGetSessionUserData), &CommonGetSessionUserData)
			if err != nil {
				panic(errors.Wrapf(err, "unmarshalling CommonGetSessionUserData from %v:", flagCommonGetSessionUserData))
			}
		}

		request, err := handlers.GetSessionUserData(CommonGetSessionUserData)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error calling handlers.GetSessionUserData: %v\n", err)
			return 1
		}

		v, err := service.GetSessionUserData(ctx, request)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error calling service.GetSessionUserData: %v\n", err)
			return 1
		}
		fmt.Println("Client Requested with:")
		fmt.Println(CommonGetSessionUserData)
		fmt.Println("Server Responded with:")
		fmt.Println(v)

	case "login":
		fsLogin.Parse(flag.Args()[1:])

		var CommonLogin pb.CommonReq
		if flagCommonLogin != nil && len(*flagCommonLogin) > 0 {
			err = json.Unmarshal([]byte(*flagCommonLogin), &CommonLogin)
			if err != nil {
				panic(errors.Wrapf(err, "unmarshalling CommonLogin from %v:", flagCommonLogin))
			}
		}

		UserNameLogin := *flagUserNameLogin
		PasswordLogin := *flagPasswordLogin

		request, err := handlers.Login(CommonLogin, UserNameLogin, PasswordLogin)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error calling handlers.Login: %v\n", err)
			return 1
		}

		v, err := service.Login(ctx, request)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error calling service.Login: %v\n", err)
			return 1
		}
		fmt.Println("Client Requested with:")
		fmt.Println(CommonLogin, UserNameLogin, PasswordLogin)
		fmt.Println("Server Responded with:")
		fmt.Println(v)

	case "logout":
		fsLogout.Parse(flag.Args()[1:])

		var CommonLogout pb.CommonReq
		if flagCommonLogout != nil && len(*flagCommonLogout) > 0 {
			err = json.Unmarshal([]byte(*flagCommonLogout), &CommonLogout)
			if err != nil {
				panic(errors.Wrapf(err, "unmarshalling CommonLogout from %v:", flagCommonLogout))
			}
		}

		request, err := handlers.Logout(CommonLogout)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error calling handlers.Logout: %v\n", err)
			return 1
		}

		v, err := service.Logout(ctx, request)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error calling service.Logout: %v\n", err)
			return 1
		}
		fmt.Println("Client Requested with:")
		fmt.Println(CommonLogout)
		fmt.Println("Server Responded with:")
		fmt.Println(v)

	case "registerapp":
		fsRegisterApp.Parse(flag.Args()[1:])

		var CommonRegisterApp pb.CommonReq
		if flagCommonRegisterApp != nil && len(*flagCommonRegisterApp) > 0 {
			err = json.Unmarshal([]byte(*flagCommonRegisterApp), &CommonRegisterApp)
			if err != nil {
				panic(errors.Wrapf(err, "unmarshalling CommonRegisterApp from %v:", flagCommonRegisterApp))
			}
		}

		AppNameRegisterApp := *flagAppNameRegisterApp
		AppRedirectIdRegisterApp := *flagAppRedirectIdRegisterApp

		request, err := handlers.RegisterApp(CommonRegisterApp, AppNameRegisterApp, AppRedirectIdRegisterApp)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error calling handlers.RegisterApp: %v\n", err)
			return 1
		}

		v, err := service.RegisterApp(ctx, request)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error calling service.RegisterApp: %v\n", err)
			return 1
		}
		fmt.Println("Client Requested with:")
		fmt.Println(CommonRegisterApp, AppNameRegisterApp, AppRedirectIdRegisterApp)
		fmt.Println("Server Responded with:")
		fmt.Println(v)

	case "registerldapaccount":
		fsRegisterLDAPAccount.Parse(flag.Args()[1:])

		var CommonRegisterLDAPAccount pb.CommonReq
		if flagCommonRegisterLDAPAccount != nil && len(*flagCommonRegisterLDAPAccount) > 0 {
			err = json.Unmarshal([]byte(*flagCommonRegisterLDAPAccount), &CommonRegisterLDAPAccount)
			if err != nil {
				panic(errors.Wrapf(err, "unmarshalling CommonRegisterLDAPAccount from %v:", flagCommonRegisterLDAPAccount))
			}
		}

		EmailRegisterLDAPAccount := *flagEmailRegisterLDAPAccount

		request, err := handlers.RegisterLDAPAccount(CommonRegisterLDAPAccount, EmailRegisterLDAPAccount)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error calling handlers.RegisterLDAPAccount: %v\n", err)
			return 1
		}

		v, err := service.RegisterLDAPAccount(ctx, request)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error calling service.RegisterLDAPAccount: %v\n", err)
			return 1
		}
		fmt.Println("Client Requested with:")
		fmt.Println(CommonRegisterLDAPAccount, EmailRegisterLDAPAccount)
		fmt.Println("Server Responded with:")
		fmt.Println(v)

	case "registerlocalaccount":
		fsRegisterLocalAccount.Parse(flag.Args()[1:])

		var CommonRegisterLocalAccount pb.CommonReq
		if flagCommonRegisterLocalAccount != nil && len(*flagCommonRegisterLocalAccount) > 0 {
			err = json.Unmarshal([]byte(*flagCommonRegisterLocalAccount), &CommonRegisterLocalAccount)
			if err != nil {
				panic(errors.Wrapf(err, "unmarshalling CommonRegisterLocalAccount from %v:", flagCommonRegisterLocalAccount))
			}
		}

		EmailRegisterLocalAccount := *flagEmailRegisterLocalAccount
		UserNameRegisterLocalAccount := *flagUserNameRegisterLocalAccount
		DisplayNameRegisterLocalAccount := *flagDisplayNameRegisterLocalAccount
		PasswordRegisterLocalAccount := *flagPasswordRegisterLocalAccount

		request, err := handlers.RegisterLocalAccount(CommonRegisterLocalAccount, EmailRegisterLocalAccount, UserNameRegisterLocalAccount, DisplayNameRegisterLocalAccount, PasswordRegisterLocalAccount)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error calling handlers.RegisterLocalAccount: %v\n", err)
			return 1
		}

		v, err := service.RegisterLocalAccount(ctx, request)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error calling service.RegisterLocalAccount: %v\n", err)
			return 1
		}
		fmt.Println("Client Requested with:")
		fmt.Println(CommonRegisterLocalAccount, EmailRegisterLocalAccount, UserNameRegisterLocalAccount, DisplayNameRegisterLocalAccount, PasswordRegisterLocalAccount)
		fmt.Println("Server Responded with:")
		fmt.Println(v)

	case "setsessionuserdata":
		fsSetSessionUserData.Parse(flag.Args()[1:])

		var CommonSetSessionUserData pb.CommonReq
		if flagCommonSetSessionUserData != nil && len(*flagCommonSetSessionUserData) > 0 {
			err = json.Unmarshal([]byte(*flagCommonSetSessionUserData), &CommonSetSessionUserData)
			if err != nil {
				panic(errors.Wrapf(err, "unmarshalling CommonSetSessionUserData from %v:", flagCommonSetSessionUserData))
			}
		}

		UserDataSetSessionUserData := *flagUserDataSetSessionUserData

		request, err := handlers.SetSessionUserData(CommonSetSessionUserData, UserDataSetSessionUserData)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error calling handlers.SetSessionUserData: %v\n", err)
			return 1
		}

		v, err := service.SetSessionUserData(ctx, request)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error calling service.SetSessionUserData: %v\n", err)
			return 1
		}
		fmt.Println("Client Requested with:")
		fmt.Println(CommonSetSessionUserData, UserDataSetSessionUserData)
		fmt.Println("Server Responded with:")
		fmt.Println(v)

	case "unregisteraccount":
		fsUnRegisterAccount.Parse(flag.Args()[1:])

		var CommonUnRegisterAccount pb.CommonReq
		if flagCommonUnRegisterAccount != nil && len(*flagCommonUnRegisterAccount) > 0 {
			err = json.Unmarshal([]byte(*flagCommonUnRegisterAccount), &CommonUnRegisterAccount)
			if err != nil {
				panic(errors.Wrapf(err, "unmarshalling CommonUnRegisterAccount from %v:", flagCommonUnRegisterAccount))
			}
		}

		AccountIdUnRegisterAccount := *flagAccountIdUnRegisterAccount

		request, err := handlers.UnRegisterAccount(CommonUnRegisterAccount, AccountIdUnRegisterAccount)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error calling handlers.UnRegisterAccount: %v\n", err)
			return 1
		}

		v, err := service.UnRegisterAccount(ctx, request)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error calling service.UnRegisterAccount: %v\n", err)
			return 1
		}
		fmt.Println("Client Requested with:")
		fmt.Println(CommonUnRegisterAccount, AccountIdUnRegisterAccount)
		fmt.Println("Server Responded with:")
		fmt.Println(v)

	case "unregisterapp":
		fsUnRegisterApp.Parse(flag.Args()[1:])

		var CommonUnRegisterApp pb.CommonReq
		if flagCommonUnRegisterApp != nil && len(*flagCommonUnRegisterApp) > 0 {
			err = json.Unmarshal([]byte(*flagCommonUnRegisterApp), &CommonUnRegisterApp)
			if err != nil {
				panic(errors.Wrapf(err, "unmarshalling CommonUnRegisterApp from %v:", flagCommonUnRegisterApp))
			}
		}

		request, err := handlers.UnRegisterApp(CommonUnRegisterApp)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error calling handlers.UnRegisterApp: %v\n", err)
			return 1
		}

		v, err := service.UnRegisterApp(ctx, request)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error calling service.UnRegisterApp: %v\n", err)
			return 1
		}
		fmt.Println("Client Requested with:")
		fmt.Println(CommonUnRegisterApp)
		fmt.Println("Server Responded with:")
		fmt.Println(v)

	default:
		flag.Usage()
		return 1
	}

	return 0
}
