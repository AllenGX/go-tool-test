// Code generated by truss. DO NOT EDIT.
// Rerunning truss will overwrite this file.
// Version: 7dc4d5d85c
// Version Date: Mon May 28 22:12:59 UTC 2018

package svc

// This file contains methods to make individual endpoints from services,
// request and response types to serve those endpoints, as well as encoders and
// decoders for those types, for all of our supported transport serialization
// formats.

import (
	"context"
	"fmt"

	"github.com/go-kit/kit/endpoint"

	pb "test/accountsvc/rpc/pb"
)

// Endpoints collects all of the endpoints that compose an add service. It's
// meant to be used as a helper struct, to collect all of the endpoints into a
// single parameter.
//
// In a server, it's useful for functions that need to operate on a per-endpoint
// basis. For example, you might pass an Endpoints to a function that produces
// an http.Handler, with each method (endpoint) wired up to a specific path. (It
// is probably a mistake in design to invoke the Service methods on the
// Endpoints struct in a server.)
//
// In a client, it's useful to collect individually constructed endpoints into a
// single type that implements the Service interface. For example, you might
// construct individual endpoints using transport/http.NewClient, combine them into an Endpoints, and return it to the caller as a Service.
type Endpoints struct {
	RegisterLocalAccountEndpoint endpoint.Endpoint
	RegisterLDAPAccountEndpoint  endpoint.Endpoint
	UnRegisterAccountEndpoint    endpoint.Endpoint
	GetAccountInfoEndpoint       endpoint.Endpoint
	GetAccountCountEndpoint      endpoint.Endpoint
	GetAccountListEndpoint       endpoint.Endpoint
	LoginEndpoint                endpoint.Endpoint
	LogoutEndpoint               endpoint.Endpoint
	GetSessionInfoEndpoint       endpoint.Endpoint
	SetSessionUserDataEndpoint   endpoint.Endpoint
	GetSessionUserDataEndpoint   endpoint.Endpoint
	RegisterAppEndpoint          endpoint.Endpoint
	UnRegisterAppEndpoint        endpoint.Endpoint
}

// Endpoints

func (e Endpoints) RegisterLocalAccount(ctx context.Context, in *pb.RegisterLocalAccountReq) (*pb.RegisterLocalAccountRsp, error) {
	response, err := e.RegisterLocalAccountEndpoint(ctx, in)
	if err != nil {
		return nil, err
	}
	return response.(*pb.RegisterLocalAccountRsp), nil
}

func (e Endpoints) RegisterLDAPAccount(ctx context.Context, in *pb.RegisterLDAPAccountReq) (*pb.RegisterLDAPAccountRsp, error) {
	response, err := e.RegisterLDAPAccountEndpoint(ctx, in)
	if err != nil {
		return nil, err
	}
	return response.(*pb.RegisterLDAPAccountRsp), nil
}

func (e Endpoints) UnRegisterAccount(ctx context.Context, in *pb.UnRegisterAccountReq) (*pb.UnRegisterAccountRsp, error) {
	response, err := e.UnRegisterAccountEndpoint(ctx, in)
	if err != nil {
		return nil, err
	}
	return response.(*pb.UnRegisterAccountRsp), nil
}

func (e Endpoints) GetAccountInfo(ctx context.Context, in *pb.GetAccountInfoReq) (*pb.GetAccountInfoRsp, error) {
	response, err := e.GetAccountInfoEndpoint(ctx, in)
	if err != nil {
		return nil, err
	}
	return response.(*pb.GetAccountInfoRsp), nil
}

func (e Endpoints) GetAccountCount(ctx context.Context, in *pb.GetAccountCountReq) (*pb.GetAccountCountRsp, error) {
	response, err := e.GetAccountCountEndpoint(ctx, in)
	if err != nil {
		return nil, err
	}
	return response.(*pb.GetAccountCountRsp), nil
}

func (e Endpoints) GetAccountList(ctx context.Context, in *pb.GetAccountListReq) (*pb.GetAccountListRsp, error) {
	response, err := e.GetAccountListEndpoint(ctx, in)
	if err != nil {
		return nil, err
	}
	return response.(*pb.GetAccountListRsp), nil
}

func (e Endpoints) Login(ctx context.Context, in *pb.LoginReq) (*pb.LoginRsp, error) {
	response, err := e.LoginEndpoint(ctx, in)
	if err != nil {
		return nil, err
	}
	return response.(*pb.LoginRsp), nil
}

func (e Endpoints) Logout(ctx context.Context, in *pb.LogoutReq) (*pb.LogoutRsp, error) {
	response, err := e.LogoutEndpoint(ctx, in)
	if err != nil {
		return nil, err
	}
	return response.(*pb.LogoutRsp), nil
}

func (e Endpoints) GetSessionInfo(ctx context.Context, in *pb.GetSessionInfoReq) (*pb.GetSessionInfoRsp, error) {
	response, err := e.GetSessionInfoEndpoint(ctx, in)
	if err != nil {
		return nil, err
	}
	return response.(*pb.GetSessionInfoRsp), nil
}

func (e Endpoints) SetSessionUserData(ctx context.Context, in *pb.SetSessionUserDataReq) (*pb.SetSessionUserDataRsp, error) {
	response, err := e.SetSessionUserDataEndpoint(ctx, in)
	if err != nil {
		return nil, err
	}
	return response.(*pb.SetSessionUserDataRsp), nil
}

func (e Endpoints) GetSessionUserData(ctx context.Context, in *pb.GetSessionUserDataReq) (*pb.GetSessionUserDataRsp, error) {
	response, err := e.GetSessionUserDataEndpoint(ctx, in)
	if err != nil {
		return nil, err
	}
	return response.(*pb.GetSessionUserDataRsp), nil
}

func (e Endpoints) RegisterApp(ctx context.Context, in *pb.RegisterAppReq) (*pb.RegisterAppRsp, error) {
	response, err := e.RegisterAppEndpoint(ctx, in)
	if err != nil {
		return nil, err
	}
	return response.(*pb.RegisterAppRsp), nil
}

func (e Endpoints) UnRegisterApp(ctx context.Context, in *pb.UnRegisterAppReq) (*pb.UnRegisterAppRsp, error) {
	response, err := e.UnRegisterAppEndpoint(ctx, in)
	if err != nil {
		return nil, err
	}
	return response.(*pb.UnRegisterAppRsp), nil
}

// Make Endpoints

func MakeRegisterLocalAccountEndpoint(s pb.AccountServer) endpoint.Endpoint {
	return func(ctx context.Context, request interface{}) (response interface{}, err error) {
		req := request.(*pb.RegisterLocalAccountReq)
		v, err := s.RegisterLocalAccount(ctx, req)
		if err != nil {
			return nil, err
		}
		return v, nil
	}
}

func MakeRegisterLDAPAccountEndpoint(s pb.AccountServer) endpoint.Endpoint {
	return func(ctx context.Context, request interface{}) (response interface{}, err error) {
		req := request.(*pb.RegisterLDAPAccountReq)
		v, err := s.RegisterLDAPAccount(ctx, req)
		if err != nil {
			return nil, err
		}
		return v, nil
	}
}

func MakeUnRegisterAccountEndpoint(s pb.AccountServer) endpoint.Endpoint {
	return func(ctx context.Context, request interface{}) (response interface{}, err error) {
		req := request.(*pb.UnRegisterAccountReq)
		v, err := s.UnRegisterAccount(ctx, req)
		if err != nil {
			return nil, err
		}
		return v, nil
	}
}

func MakeGetAccountInfoEndpoint(s pb.AccountServer) endpoint.Endpoint {
	return func(ctx context.Context, request interface{}) (response interface{}, err error) {
		req := request.(*pb.GetAccountInfoReq)
		v, err := s.GetAccountInfo(ctx, req)
		if err != nil {
			return nil, err
		}
		return v, nil
	}
}

func MakeGetAccountCountEndpoint(s pb.AccountServer) endpoint.Endpoint {
	return func(ctx context.Context, request interface{}) (response interface{}, err error) {
		req := request.(*pb.GetAccountCountReq)
		v, err := s.GetAccountCount(ctx, req)
		if err != nil {
			return nil, err
		}
		return v, nil
	}
}

func MakeGetAccountListEndpoint(s pb.AccountServer) endpoint.Endpoint {
	return func(ctx context.Context, request interface{}) (response interface{}, err error) {
		req := request.(*pb.GetAccountListReq)
		v, err := s.GetAccountList(ctx, req)
		if err != nil {
			return nil, err
		}
		return v, nil
	}
}

func MakeLoginEndpoint(s pb.AccountServer) endpoint.Endpoint {
	return func(ctx context.Context, request interface{}) (response interface{}, err error) {
		req := request.(*pb.LoginReq)
		v, err := s.Login(ctx, req)
		if err != nil {
			return nil, err
		}
		return v, nil
	}
}

func MakeLogoutEndpoint(s pb.AccountServer) endpoint.Endpoint {
	return func(ctx context.Context, request interface{}) (response interface{}, err error) {
		req := request.(*pb.LogoutReq)
		v, err := s.Logout(ctx, req)
		if err != nil {
			return nil, err
		}
		return v, nil
	}
}

func MakeGetSessionInfoEndpoint(s pb.AccountServer) endpoint.Endpoint {
	return func(ctx context.Context, request interface{}) (response interface{}, err error) {
		req := request.(*pb.GetSessionInfoReq)
		v, err := s.GetSessionInfo(ctx, req)
		if err != nil {
			return nil, err
		}
		return v, nil
	}
}

func MakeSetSessionUserDataEndpoint(s pb.AccountServer) endpoint.Endpoint {
	return func(ctx context.Context, request interface{}) (response interface{}, err error) {
		req := request.(*pb.SetSessionUserDataReq)
		v, err := s.SetSessionUserData(ctx, req)
		if err != nil {
			return nil, err
		}
		return v, nil
	}
}

func MakeGetSessionUserDataEndpoint(s pb.AccountServer) endpoint.Endpoint {
	return func(ctx context.Context, request interface{}) (response interface{}, err error) {
		req := request.(*pb.GetSessionUserDataReq)
		v, err := s.GetSessionUserData(ctx, req)
		if err != nil {
			return nil, err
		}
		return v, nil
	}
}

func MakeRegisterAppEndpoint(s pb.AccountServer) endpoint.Endpoint {
	return func(ctx context.Context, request interface{}) (response interface{}, err error) {
		req := request.(*pb.RegisterAppReq)
		v, err := s.RegisterApp(ctx, req)
		if err != nil {
			return nil, err
		}
		return v, nil
	}
}

func MakeUnRegisterAppEndpoint(s pb.AccountServer) endpoint.Endpoint {
	return func(ctx context.Context, request interface{}) (response interface{}, err error) {
		req := request.(*pb.UnRegisterAppReq)
		v, err := s.UnRegisterApp(ctx, req)
		if err != nil {
			return nil, err
		}
		return v, nil
	}
}

// WrapAllExcept wraps each Endpoint field of struct Endpoints with a
// go-kit/kit/endpoint.Middleware.
// Use this for applying a set of middlewares to every endpoint in the service.
// Optionally, endpoints can be passed in by name to be excluded from being wrapped.
// WrapAllExcept(middleware, "Status", "Ping")
func (e *Endpoints) WrapAllExcept(middleware endpoint.Middleware, excluded ...string) {
	included := map[string]struct{}{
		"RegisterLocalAccount": struct{}{},
		"RegisterLDAPAccount":  struct{}{},
		"UnRegisterAccount":    struct{}{},
		"GetAccountInfo":       struct{}{},
		"GetAccountCount":      struct{}{},
		"GetAccountList":       struct{}{},
		"Login":                struct{}{},
		"Logout":               struct{}{},
		"GetSessionInfo":       struct{}{},
		"SetSessionUserData":   struct{}{},
		"GetSessionUserData":   struct{}{},
		"RegisterApp":          struct{}{},
		"UnRegisterApp":        struct{}{},
	}

	for _, ex := range excluded {
		if _, ok := included[ex]; !ok {
			panic(fmt.Sprintf("Excluded endpoint '%s' does not exist; see middlewares/endpoints.go", ex))
		}
		delete(included, ex)
	}

	for inc, _ := range included {
		if inc == "RegisterLocalAccount" {
			e.RegisterLocalAccountEndpoint = middleware(e.RegisterLocalAccountEndpoint)
		}
		if inc == "RegisterLDAPAccount" {
			e.RegisterLDAPAccountEndpoint = middleware(e.RegisterLDAPAccountEndpoint)
		}
		if inc == "UnRegisterAccount" {
			e.UnRegisterAccountEndpoint = middleware(e.UnRegisterAccountEndpoint)
		}
		if inc == "GetAccountInfo" {
			e.GetAccountInfoEndpoint = middleware(e.GetAccountInfoEndpoint)
		}
		if inc == "GetAccountCount" {
			e.GetAccountCountEndpoint = middleware(e.GetAccountCountEndpoint)
		}
		if inc == "GetAccountList" {
			e.GetAccountListEndpoint = middleware(e.GetAccountListEndpoint)
		}
		if inc == "Login" {
			e.LoginEndpoint = middleware(e.LoginEndpoint)
		}
		if inc == "Logout" {
			e.LogoutEndpoint = middleware(e.LogoutEndpoint)
		}
		if inc == "GetSessionInfo" {
			e.GetSessionInfoEndpoint = middleware(e.GetSessionInfoEndpoint)
		}
		if inc == "SetSessionUserData" {
			e.SetSessionUserDataEndpoint = middleware(e.SetSessionUserDataEndpoint)
		}
		if inc == "GetSessionUserData" {
			e.GetSessionUserDataEndpoint = middleware(e.GetSessionUserDataEndpoint)
		}
		if inc == "RegisterApp" {
			e.RegisterAppEndpoint = middleware(e.RegisterAppEndpoint)
		}
		if inc == "UnRegisterApp" {
			e.UnRegisterAppEndpoint = middleware(e.UnRegisterAppEndpoint)
		}
	}
}

// LabeledMiddleware will get passed the endpoint name when passed to
// WrapAllLabeledExcept, this can be used to write a generic metrics
// middleware which can send the endpoint name to the metrics collector.
type LabeledMiddleware func(string, endpoint.Endpoint) endpoint.Endpoint

// WrapAllLabeledExcept wraps each Endpoint field of struct Endpoints with a
// LabeledMiddleware, which will receive the name of the endpoint. See
// LabeldMiddleware. See method WrapAllExept for details on excluded
// functionality.
func (e *Endpoints) WrapAllLabeledExcept(middleware func(string, endpoint.Endpoint) endpoint.Endpoint, excluded ...string) {
	included := map[string]struct{}{
		"RegisterLocalAccount": struct{}{},
		"RegisterLDAPAccount":  struct{}{},
		"UnRegisterAccount":    struct{}{},
		"GetAccountInfo":       struct{}{},
		"GetAccountCount":      struct{}{},
		"GetAccountList":       struct{}{},
		"Login":                struct{}{},
		"Logout":               struct{}{},
		"GetSessionInfo":       struct{}{},
		"SetSessionUserData":   struct{}{},
		"GetSessionUserData":   struct{}{},
		"RegisterApp":          struct{}{},
		"UnRegisterApp":        struct{}{},
	}

	for _, ex := range excluded {
		if _, ok := included[ex]; !ok {
			panic(fmt.Sprintf("Excluded endpoint '%s' does not exist; see middlewares/endpoints.go", ex))
		}
		delete(included, ex)
	}

	for inc, _ := range included {
		if inc == "RegisterLocalAccount" {
			e.RegisterLocalAccountEndpoint = middleware("RegisterLocalAccount", e.RegisterLocalAccountEndpoint)
		}
		if inc == "RegisterLDAPAccount" {
			e.RegisterLDAPAccountEndpoint = middleware("RegisterLDAPAccount", e.RegisterLDAPAccountEndpoint)
		}
		if inc == "UnRegisterAccount" {
			e.UnRegisterAccountEndpoint = middleware("UnRegisterAccount", e.UnRegisterAccountEndpoint)
		}
		if inc == "GetAccountInfo" {
			e.GetAccountInfoEndpoint = middleware("GetAccountInfo", e.GetAccountInfoEndpoint)
		}
		if inc == "GetAccountCount" {
			e.GetAccountCountEndpoint = middleware("GetAccountCount", e.GetAccountCountEndpoint)
		}
		if inc == "GetAccountList" {
			e.GetAccountListEndpoint = middleware("GetAccountList", e.GetAccountListEndpoint)
		}
		if inc == "Login" {
			e.LoginEndpoint = middleware("Login", e.LoginEndpoint)
		}
		if inc == "Logout" {
			e.LogoutEndpoint = middleware("Logout", e.LogoutEndpoint)
		}
		if inc == "GetSessionInfo" {
			e.GetSessionInfoEndpoint = middleware("GetSessionInfo", e.GetSessionInfoEndpoint)
		}
		if inc == "SetSessionUserData" {
			e.SetSessionUserDataEndpoint = middleware("SetSessionUserData", e.SetSessionUserDataEndpoint)
		}
		if inc == "GetSessionUserData" {
			e.GetSessionUserDataEndpoint = middleware("GetSessionUserData", e.GetSessionUserDataEndpoint)
		}
		if inc == "RegisterApp" {
			e.RegisterAppEndpoint = middleware("RegisterApp", e.RegisterAppEndpoint)
		}
		if inc == "UnRegisterApp" {
			e.UnRegisterAppEndpoint = middleware("UnRegisterApp", e.UnRegisterAppEndpoint)
		}
	}
}
